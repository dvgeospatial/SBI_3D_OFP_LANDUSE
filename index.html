<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SBI: Solid 3D Woodland (20m)</title>
  <!-- CesiumJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.110.0/Cesium.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.110.0/Widgets/widgets.css" rel="stylesheet">
  <!-- Proj4 for Coordinate Transformation -->
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.0/dist/proj4.js"></script>
  <!-- Turf.js for Geometry Processing -->
  <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
  
  <style>
    body, html, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #dcdcdc; font-family: sans-serif; }
    
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      background: rgba(255, 255, 255, 0.95); padding: 12px; border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.2); width: 220px;
    }
    input[type="text"] { padding: 5px; width: 100%; box-sizing: border-box; margin-bottom: 8px; border: 1px solid #ccc; }
    button {
      padding: 8px; background-color: #333; color: white; border: none; 
      border-radius: 3px; cursor: pointer; width: 100%; font-weight: bold; margin-bottom: 8px;
    }
    button:hover { background-color: #555; }
    
    .layer-row { display: flex; align-items: center; font-size: 13px; cursor: pointer; margin-bottom: 5px; color: #333; }
    .layer-row input { margin-right: 8px; cursor: pointer; }

    #loadingIndicator { 
        font-size: 11px; color: #666; margin-top: 5px; display: none; font-style: italic; 
    }

    #legendPanel {
      position: absolute; bottom: 30px; right: 10px;
      background: rgba(255, 255, 255, 0.95); padding: 10px;
      border-radius: 5px; z-index: 100; max-height: 400px;
      overflow-y: auto; width: 220px; display: none;
      box-shadow: 0 1px 5px rgba(0,0,0,0.2);
    }
    .legend-item { display: flex; align-items: center; margin-bottom: 4px; font-size: 12px; color: #333; }
    .legend-item i {
      width: 18px; height: 18px; float: left; margin-right: 8px;
      opacity: 0.8; border: 1px solid #999; flex-shrink: 0;
    }
    h4 { margin: 0 0 10px 0; font-size: 14px; border-bottom: 1px solid #ccc; padding-bottom: 5px; color: #333; }
  </style>
</head>
<body>

  <div id="controls">
    <label style="font-size:12px; font-weight:bold; color:#333;">Enter SBI Number:</label>
    <input type="text" id="sbiInput" value="106592409" placeholder="e.g. 106592409">
    <button onclick="runMapUpdate()">Load SBI Data</button>
    
    <div class="layer-row">
        <input type="checkbox" id="chkOFP" checked onchange="toggleOFP(this.checked)">
        <label for="chkOFP">Show Flow Pathways (Simplified)</label>
    </div>

    <div id="loadingIndicator"></div>
  </div>

  <div id="legendPanel"></div>
  <div id="cesiumContainer"></div>

  <script>
    // 1. Setup Proj4 (British National Grid to WGS84)
    proj4.defs("EPSG:27700", "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs");

    // Colors
    const landCoverColors = {
        'Arable Land': '#F0E68C', 'Permanent Grassland': '#32CD32', 'Woodland': '#228B22',
        'Natural Woodland': '#006400', 'Pond': '#4682B4', 'Rivers and streams type 3': '#1E90FF',
        'Drain/Ditch/Dyke': '#00BFFF', 'Farm Building': '#8B4513', 'Residential dwelling, House': '#CD5C5C',
        'Farmyards': '#D2B48C', 'Track - Natural Surface': '#DEB887', 'Metalled track': '#808080',
        'Residential Gardens': '#90EE90', 'Non-agricultural land': '#A9A9A9', 'default': '#FFeda0'
    };

    // 2. Initialize Viewer with Anti-Aliasing Enabled
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: undefined, // Flat ellipsoid
      baseLayerPicker: false,
      timeline: false,
      animation: false,
      scene3DOnly: true,
      infoBox: true,
      selectionIndicator: true,
      baseLayer: new Cesium.ImageryLayer(new Cesium.UrlTemplateImageryProvider({
        url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
        subdomains: ['a', 'b', 'c', 'd'],
        credit: '© OpenStreetMap contributors, © CARTO'
      }))
    });

    // --- Optimization: Enable Hardware Smoothing (MSAA) ---
    viewer.scene.msaaSamples = 4; 
    viewer.scene.postProcessStages.fxaa.enabled = true; 

    // 3. State Management
    let dsRPA = null;
    let dsOutlines = null;
    let dsOFP = null;
    let sbiBbox = null;

    // --- Helper: Resample LineString to vertex every 10m ---
    function resampleLine(lineFeature, intervalMeters = 10) {
        const length = turf.length(lineFeature, {units: 'meters'});
        if (length <= intervalMeters) return lineFeature;

        const newCoords = [];
        for (let step = 0; step <= length; step += intervalMeters) {
            const pt = turf.along(lineFeature, step, {units: 'meters'});
            newCoords.push(pt.geometry.coordinates);
        }
        const endPt = turf.along(lineFeature, length, {units: 'meters'});
        newCoords.push(endPt.geometry.coordinates);

        return turf.lineString(newCoords, lineFeature.properties);
    }

    // --- Helper: Reproject BNG -> WGS84 + Add Height Buffer ---
    function reprojectGeoJSON(geojson) {
        let cloned = JSON.parse(JSON.stringify(geojson));
        
        // Transform adds 2m height for SBI Outlines
        const transform = (coords) => {
            const wgs = proj4('EPSG:27700', 'EPSG:4326', coords);
            return [wgs[0], wgs[1], 2]; // 2 meters for outlines
        };

        const transformGeometry = (geometry) => {
            if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                geometry.coordinates = geometry.coordinates.map(ring => ring.map(transform));
            } else if (geometry.type === 'MultiPolygon') {
                geometry.coordinates = geometry.coordinates.map(poly => poly.map(ring => ring.map(transform)));
            } else if (geometry.type === 'LineString') {
                geometry.coordinates = geometry.coordinates.map(transform);
            }
        };

        if (cloned.type === 'FeatureCollection') {
            cloned.features.forEach(f => transformGeometry(f.geometry));
        } else if (cloned.type === 'Feature') {
            transformGeometry(cloned.geometry);
        }
        return turf.rewind(cloned, {reverse: false, mutate: true});
    }

    // --- Main Update Function ---
    async function runMapUpdate() {
        const sbi = document.getElementById('sbiInput').value.trim();
        const loader = document.getElementById('loadingIndicator');
        const legend = document.getElementById('legendPanel');
        
        if(!sbi) return alert("Enter SBI");
        
        // Cleanup
        if(dsRPA) viewer.dataSources.remove(dsRPA);
        if(dsOutlines) viewer.dataSources.remove(dsOutlines);
        if(dsOFP) viewer.dataSources.remove(dsOFP);
        
        legend.style.display = 'none';
        loader.style.display = 'block';
        loader.innerText = "Fetching RPA Data...";

        try {
            // A. Load RPA Data
            const url = `https://environment.data.gov.uk/data-services/RPA/LandCovers/wfs?version=2.0.0&request=GetFeature&typeNames=RPA:LandCovers&cql_filter=SBI=${sbi}&srsname=EPSG:27700&outputFormat=application/json`;
            const response = await fetch(url);
            if(!response.ok) throw new Error("RPA Service Error");
            const data = await response.json();
            if (!data.features || data.features.length === 0) throw new Error("No SBI Data found");

            // Reproject to WGS84 with Z=2m
            const wgs84Data = reprojectGeoJSON(data);
            
            // 1. Load Fills (Unclamped for 3D extrusion)
            dsRPA = await Cesium.GeoJsonDataSource.load(wgs84Data, { clampToGround: false });
            const entities = dsRPA.entities.values;
            const foundCategories = new Set();
            for (let i = 0; i < entities.length; i++) {
                const entity = entities[i];
                const desc = entity.properties.DESCRIPTION ? entity.properties.DESCRIPTION.getValue() : 'default';
                foundCategories.add(desc);
                const colorCss = landCoverColors[desc] || landCoverColors['default'];
                const color = Cesium.Color.fromCssColorString(colorCss);
                
                if(entity.polygon) {
                    entity.polygon.outline = false; 
                    entity.polygon.height = 0; // Base at 0
                    
                    // Logic for Woodland Extrusion
                    if (desc === 'Woodland' || desc === 'Natural Woodland') {
                        entity.polygon.extrudedHeight = 20; // 20m Height
                        entity.polygon.material = color;    // Solid Opaque
                    } else {
                        entity.polygon.extrudedHeight = undefined; // Flat
                        entity.polygon.material = color.withAlpha(0.6); // Transparent
                    }
                }
            }
            viewer.dataSources.add(dsRPA);

            // 2. Load Outlines (Floating at 2m)
            const outlinesGeoJSON = { type: "FeatureCollection", features: [] };
            wgs84Data.features.forEach(f => {
                if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') {
                    const lines = turf.polygonToLine(f);
                    if (lines.type === 'FeatureCollection') outlinesGeoJSON.features.push(...lines.features);
                    else outlinesGeoJSON.features.push(lines);
                }
            });

            dsOutlines = await Cesium.GeoJsonDataSource.load(outlinesGeoJSON, { clampToGround: false });
            const outlineEntities = dsOutlines.entities.values;
            for(let i=0; i<outlineEntities.length; i++) {
                const ent = outlineEntities[i];
                if(ent.polyline) {
                    ent.polyline.material = Cesium.Color.BLACK;
                    ent.polyline.width = 1.0; 
                }
            }
            viewer.dataSources.add(dsOutlines);

            viewer.zoomTo(dsRPA);

            // B. Build Legend
            legend.innerHTML = '<h4>Land Cover</h4>';
            Array.from(foundCategories).sort().forEach(c => {
                const color = landCoverColors[c] || landCoverColors['default'];
                legend.innerHTML += `<div class="legend-item"><i style="background:${color}"></i><span>${c}</span></div>`;
            });
            legend.innerHTML += `<hr><div style="font-weight:bold; font-size:11px; margin-bottom:5px;">Flow Pathways (10m resampled):</div>
            <div class="legend-item"><i style="background:red; height:3px; margin-top:7px"></i><span>High Flow</span></div>
            <div class="legend-item"><i style="background:blue; height:1px; margin-top:9px"></i><span>Low Flow</span></div>`;
            legend.style.display = 'block';

            // C. Trigger OFP
            let bbox = turf.bbox(wgs84Data);
            if(bbox.length === 6) {
                 sbiBbox = [bbox[0], bbox[1], bbox[3], bbox[4]];
            } else {
                 sbiBbox = bbox;
            }

            if(document.getElementById('chkOFP').checked) {
                loadFilteredOFP(sbiBbox);
            } else {
                loader.innerText = "Ready.";
            }

        } catch (e) {
            console.error(e);
            loader.innerText = "Error: " + e.message;
        }
    }

    // --- Flow Pathways Logic ---
    function loadFilteredOFP(bboxArray) {
        const loader = document.getElementById('loadingIndicator');
        loader.innerText = "Fetching Flow Pathways...";
        
        const bboxStr = bboxArray.join(',');
        const ofpUrl = "https://services1.arcgis.com/JZM7qJpmv7vJ0Hzx/arcgis/rest/services/OverlandFlowPathwaysForPublicALERTEngland_20240318/FeatureServer/0";
        
        fetch(`${ofpUrl}/query?f=geojson&geometry=${bboxStr}&geometryType=esriGeometryEnvelope&spatialRel=esriSpatialRelIntersects&outFields=*&outSR=4326`)
        .then(r => r.json())
        .then(async data => {
            if(!data.features || data.features.length === 0) {
                loader.innerText = "No Flow Pathways found.";
                return;
            }
            
            loader.innerText = `Simplifying ${data.features.length} lines...`;
            await new Promise(r => setTimeout(r, 20));

            const processedFeatures = data.features.map(f => {
                let geom = f;
                
                // 1. Resample logic
                if(f.geometry.type === 'LineString') {
                    geom = resampleLine(f, 10);
                }
                
                // 2. Float Logic: Add 4m height to OFP
                geom.geometry.coordinates = geom.geometry.coordinates.map(c => [c[0], c[1], 4]); // 4 meters
                
                return geom;
            });

            const fc = turf.featureCollection(processedFeatures);
            
            dsOFP = await Cesium.GeoJsonDataSource.load(fc, { clampToGround: false });
            
            const entities = dsOFP.entities.values;
            for(let i=0; i<entities.length; i++) {
                const ent = entities[i];
                const flowVal = ent.properties.MaxFlowAcc ? ent.properties.MaxFlowAcc.getValue() : 0;
                
                let color, width;
                if (flowVal >= 50000) { 
                    color = Cesium.Color.RED; 
                    width = 2.0; 
                } else { 
                    color = Cesium.Color.BLUE; 
                    width = 1.0; 
                } 

                if(ent.polyline) {
                    ent.polyline.material = color;
                    ent.polyline.width = width;
                    ent.polyline.clampToGround = false; 
                }
            }
            
            if(document.getElementById('chkOFP').checked) {
                viewer.dataSources.add(dsOFP);
            }
            loader.innerText = "Ready.";
        })
        .catch(e => {
            console.error(e);
            loader.innerText = "OFP Error";
        });
    }

    function toggleOFP(checked) {
        if(checked) {
            if(dsOFP) {
                if(!viewer.dataSources.contains(dsOFP)) viewer.dataSources.add(dsOFP);
            } else if(sbiBbox) {
                loadFilteredOFP(sbiBbox);
            }
        } else {
            if(dsOFP) viewer.dataSources.remove(dsOFP);
        }
    }

    runMapUpdate();
  </script>
</body>
</html>
